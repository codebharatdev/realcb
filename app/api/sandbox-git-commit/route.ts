import { NextRequest, NextResponse } from 'next/server';
import { getFirebaseForAPI } from '@/lib/firebase-utils';

declare global {
  var activeSandbox: any;
}

export async function POST(request: NextRequest) {
  try {
    const { repoName, commitMessage, userId } = await request.json();
    
    if (!repoName || !commitMessage || !userId) {
      return NextResponse.json({
        success: false,
        error: 'Missing required fields: repoName, commitMessage, and userId are required'
      }, { status: 400 });
    }

    if (!global.activeSandbox) {
      return NextResponse.json({
        success: false,
        error: 'No active sandbox'
      }, { status: 404 });
    }

    const { db, firestore } = getFirebaseForAPI();
    
         if (!db || !firestore) {
       return NextResponse.json({
         success: false,
         error: 'GitHub not connected. Please connect your GitHub account first.'
       }, { status: 401 });
     }
    
    // Get user's GitHub access token from Firestore
    const userRef = firestore.doc(db, 'users', userId);
    const userSnap = await firestore.getDoc(userRef);
    
    if (!userSnap.exists()) {
      return NextResponse.json({
        success: false,
        error: 'User not found'
      }, { status: 404 });
    }

    const userData = userSnap.data();
    
    if (!userData.githubConnected || !userData.githubAccessToken) {
      return NextResponse.json({
        success: false,
        error: 'GitHub account not connected. Please connect your GitHub account first.'
      }, { status: 401 });
    }

    console.log('[sandbox-git-commit] Starting git commit in sandbox:', {
      repoName,
      commitMessage,
      userId,
      githubUsername: userData.githubUsername
    });

    // First, test if the sandbox is working with a simple command
    console.log('[sandbox-git-commit] Testing sandbox connectivity...');
    const testResult = await global.activeSandbox.runCode('print("‚úÖ Sandbox is working!")');
    console.log('[sandbox-git-commit] Test result:', testResult.logs.stdout.join(''));

    // Send git commands to sandbox with proper variable substitution
    const pythonScript = `
import os
import subprocess
import json

print("üöÄ Starting git setup and commit process...")

def setup_git_and_commit():
    try:
        # Change to app directory
        os.chdir('/home/user/app')
        
        # Initialize git repository if not already done
        if not os.path.exists('.git'):
            subprocess.run(['git', 'init'], check=True, capture_output=True, text=True)
            print("‚úÖ Git repository initialized")
        
        # Configure git user
        subprocess.run(['git', 'config', 'user.name', 'CodeBharat.dev Bot'], check=True, capture_output=True, text=True)
        subprocess.run(['git', 'config', 'user.email', 'bot@codebharat.dev'], check=True, capture_output=True, text=True)
        
        # Add remote origin (repository is always new with timestamp-based names)
        remote_url = f"https://github.com/${userData.githubUsername}/${repoName}.git"
        subprocess.run(['git', 'remote', 'add', 'origin', remote_url], check=True, capture_output=True, text=True)
        print(f"‚úÖ Added remote origin: {remote_url}")
        
        # Create .gitignore file to exclude node_modules and other build artifacts
        gitignore_content = """# Dependencies
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Build outputs
dist/
build/
.next/
.nuxt/
.output/

# Environment variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# IDE files
.vscode/
.idea/
*.swp
*.swo

# OS files
.DS_Store
Thumbs.db

# Logs
logs
*.log

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Coverage directory used by tools like istanbul
coverage/
.nyc_output

# Dependency directories
jspm_packages/

# Optional npm cache directory
.npm

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Vite cache
.vite

# Temporary folders
tmp/
temp/
"""
        
        with open('.gitignore', 'w') as f:
            f.write(gitignore_content)
        print("‚úÖ Created .gitignore file")
        
        # Create README.md file
        readme_content = f"""# ${repoName}

Generated by CodeBharat.dev - AI-powered web application generator.

## Description

This application was automatically generated using CodeBharat.dev's AI-powered code generation platform.

## Getting Started

### Prerequisites

- Node.js (v16 or higher)
- npm or yarn

### Installation

1. Clone the repository:
\`\`\`bash
git clone https://github.com/${userData.githubUsername}/${repoName}.git
cd ${repoName}
\`\`\`

2. Install dependencies:
\`\`\`bash
npm install
\`\`\`

3. Start the development server:
\`\`\`bash
npm run dev
\`\`\`

4. Open your browser and navigate to \`http://localhost:5173\`

## Available Scripts

- \`npm run dev\` - Start development server
- \`npm run build\` - Build for production
- \`npm run preview\` - Preview production build

## Technologies Used

- React
- Vite
- Tailwind CSS
- Other dependencies as specified in package.json

## Generated by

[CodeBharat.dev](https://codebharat.dev) - AI-powered web application generator
"""
        
        with open('README.md', 'w') as f:
            f.write(readme_content)
        print("‚úÖ Created README.md file")
        
        # Add only source files (not node_modules)
        subprocess.run(['git', 'add', '.'], check=True, capture_output=True, text=True)
        print("‚úÖ Added source files to git (node_modules excluded)")
        
        # Commit with message
        subprocess.run(['git', 'commit', '-m', '${commitMessage}'], check=True, capture_output=True, text=True)
        print(f"‚úÖ Committed with message: ${commitMessage}")
        
        # Check current branch and create main if needed
        branch_result = subprocess.run(['git', 'branch', '--show-current'], capture_output=True, text=True)
        current_branch = branch_result.stdout.strip()
        print(f"Current branch: {current_branch}")
        
        # If we're not on main branch, create and switch to it
        if current_branch != 'main':
            subprocess.run(['git', 'branch', '-M', 'main'], check=True, capture_output=True, text=True)
            print("‚úÖ Switched to main branch")
        
        # Push to GitHub using personal access token
        # We'll use the token in the URL for authentication
        auth_url = f"https://${userData.githubAccessToken}@github.com/${userData.githubUsername}/${repoName}.git"
        
        # Update remote URL to include the token for authentication
        subprocess.run(['git', 'remote', 'set-url', 'origin', auth_url], check=True, capture_output=True, text=True)
        print(f"‚úÖ Updated remote with authentication: https://***@github.com/${userData.githubUsername}/${repoName}.git")
        
        # Push to main branch with force if needed (for initial push)
        try:
            subprocess.run(['git', 'push', '-u', 'origin', 'main'], check=True, capture_output=True, text=True)
            print("‚úÖ Pushed to GitHub main branch")
        except subprocess.CalledProcessError:
            # If normal push fails, try force push for initial commit
            subprocess.run(['git', 'push', '-u', 'origin', 'main', '--force'], check=True, capture_output=True, text=True)
            print("‚úÖ Force pushed to GitHub main branch")
        
        return {
            'success': True,
            'message': 'Code committed and pushed to GitHub successfully',
            'repoUrl': f"https://github.com/${userData.githubUsername}/${repoName}"
        }
        
    except subprocess.CalledProcessError as e:
        error_msg = f"Git command failed: {e.stderr}"
        print(f"‚ùå {error_msg}")
        return {
            'success': False,
            'error': error_msg,
            'command': e.cmd,
            'returncode': e.returncode
        }
    except Exception as e:
        error_msg = f"Unexpected error: {str(e)}"
        print(f"‚ùå {error_msg}")
        return {
            'success': False,
            'error': error_msg
        }

# Execute the git operations
print("üìã Executing git setup and commit...")
result = setup_git_and_commit()
print("üì§ Final result:")
print(json.dumps(result))
    `;

    // Debug: Log the script before variable substitution
    console.log('[sandbox-git-commit] Script before substitution:', pythonScript.substring(0, 200) + '...');
    console.log('[sandbox-git-commit] Variables to substitute:', {
      githubUsername: userData.githubUsername,
      githubAccessToken: userData.githubAccessToken ? '***' : 'MISSING',
      repoName,
      commitMessage
    });
    
    // Apply variable substitution
    const finalScript = pythonScript
      .replace(/\${userData\.githubUsername}/g, userData.githubUsername)
      .replace(/\${userData\.githubAccessToken}/g, userData.githubAccessToken)
      .replace(/\${repoName}/g, repoName)
      .replace(/\${commitMessage}/g, commitMessage);
    
    // Debug: Log the script after variable substitution
    console.log('[sandbox-git-commit] Script after substitution:', finalScript.substring(0, 200) + '...');
    console.log('[sandbox-git-commit] Checking for unsubstituted variables in final script...');
    const unsubstitutedVars = finalScript.match(/\${[^}]+}/g);
    if (unsubstitutedVars) {
      console.warn('[sandbox-git-commit] Found unsubstituted variables:', unsubstitutedVars);
    } else {
      console.log('[sandbox-git-commit] All variables appear to be substituted correctly');
    }
    
    const result = await global.activeSandbox.runCode(finalScript);

    const output = result.logs.stdout.join('');
    const errorOutput = result.logs.stderr.join('');
    
    console.log('[sandbox-git-commit] Sandbox stdout:', output);
    console.log('[sandbox-git-commit] Sandbox stderr:', errorOutput);
    
    // Check if there's any output at all
    if (!output && !errorOutput) {
        console.error('[sandbox-git-commit] No output from sandbox - script may not have executed');
        return NextResponse.json({
            success: false,
            error: 'No output from sandbox - script execution failed'
        }, { status: 500 });
    }
    
    // If there's stderr output, log it but don't fail immediately
    if (errorOutput) {
        console.warn('[sandbox-git-commit] Sandbox stderr output:', errorOutput);
    }
    
    let parsedResult;
    try {
        // Find the JSON result in the output
        const jsonMatch = output.match(/\{.*\}/s);
        if (jsonMatch) {
            parsedResult = JSON.parse(jsonMatch[0]);
        } else {
            // If no JSON found, try to extract any error information
            const errorInfo = errorOutput || output || 'No output available';
            throw new Error(`No JSON result found in output. Output: ${errorInfo.substring(0, 200)}...`);
        }
    } catch (error) {
        console.error('[sandbox-git-commit] Error parsing JSON:', error);
        console.error('[sandbox-git-commit] Raw stdout:', output);
        console.error('[sandbox-git-commit] Raw stderr:', errorOutput);
        return NextResponse.json({
            success: false,
            error: `Failed to parse sandbox response: ${(error as Error).message}`
        }, { status: 500 });
    }

    if (parsedResult.success) {
        console.log('[sandbox-git-commit] ‚úÖ Git commit successful:', parsedResult);
        return NextResponse.json({
            success: true,
            message: parsedResult.message,
            repoUrl: parsedResult.repoUrl
        });
    } else {
        console.error('[sandbox-git-commit] ‚ùå Git commit failed:', parsedResult);
        return NextResponse.json({
            success: false,
            error: parsedResult.error || 'Git commit failed'
        }, { status: 500 });
    }

  } catch (error) {
    console.error('[sandbox-git-commit] Error:', error);
    return NextResponse.json({
      success: false,
      error: (error as Error).message
    }, { status: 500 });
  }
}
